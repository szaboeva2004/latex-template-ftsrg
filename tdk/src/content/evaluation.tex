% \chapter{Evaluation}

% \section{Experiment Planning}

% \subsection{Research Questions}

% \subsection{Experiment design}
% \todo{Add table, metrics, variables, algorithms etc}

% \subsection{Measuremenrt Procedure}
% %Measurements were executed on physical machines with 4 core (2.50 GHz) Intel Xeon L5420 CPUs and 32 GB of RAM, running Ubuntu 18.04.1 LTS and Oracle JDK 1.8.0_191. We used z3 version 4.5.0 [MB08] for SMT solving.18 To ensure reliable and accurate measurements, we used the RunExec tool from the BenchExec suite [BLW19], which is a state-of-the-art benchmarking framework (also used at SVCOMP). Each measurement was executed with a CPU time limit of 300 seconds19 and a memory limit of 4 GB. The results were collected into CSV files for further analysis. Each measurement was repeated 2 times. Instructions to reproduce our experiment can be found in the supplementary material [a22].

% \subsection{Threats to validity ??}
% % external 
% % internal 
% % hm ez nem biztos hogy általánosságban is így van 
% \section{Results and analysis}
% %Comparing XCFAs, peformance
% %Cross checking
% %Answer research questions




% % Ebben a kiértékelésben összehasonlítottam ezt meg azt 

% ő
% % Answer research questions 
% % Konfigurációk és miért azokkal mértem 
% % baseline, pl c frontend 
% % ÉS azt látom hogy


\chapter{Evaluation}
\label{chap:evaluation}

\section{Experiment Design}
\label{sec:experiment-design}

This chapter presents a comprehensive evaluation of the BTOR2XCFA transformation approach compared to the traditional translation-based workflow using Btor2C. The evaluation focuses on structural complexity, resource requirements, and potential performance implications across multiple dimensions.

\subsection{Research Questions}
\label{subsec:research-questions}

The evaluation aims to answer the following research questions:

\begin{enumerate}
    \item \textbf{RQ1:} How does the structural complexity differ between direct BTOR2-to-CFA transformation and the Btor2C translation approach?
    \item \textbf{RQ2:} What are the resource implications (memory, processing) of each approach?
    \item \textbf{RQ3:} How do the control flow characteristics compare between the two transformation methods?
\end{enumerate}

\subsection{Benchmark Suite and Methodology}
\label{subsec:methodology}

The evaluation was conducted using 277 benchmark circuits from the Hardware Model Checking Competition (HWMCC) suite. Each circuit was processed through both transformation workflows:

\begin{itemize}
    \item \textbf{Direct Approach:} BTOR2 $\rightarrow$ CFA (BTOR2XCFA)
    \item \textbf{Translation Approach:} BTOR2 $\rightarrow$ C $\rightarrow$ CFA (Btor2C + Theta C frontend)
\end{itemize}

Multiple metrics were collected for comparative analysis, including file sizes, structural elements, label complexity, and control flow characteristics.

\section{Structural Complexity Analysis}
\label{sec:structural-complexity}

\subsection{File Size and Storage Requirements}
\label{subsec:file-size}

The analysis reveals significant differences in storage requirements between the two approaches:

\begin{table}[htbp]
    \centering
    \caption{File Size Comparison Statistics}
    \label{tab:file-size}
    \begin{tabular}{lrrr}
        \toprule
        \textbf{Statistic} & \textbf{Size Ratio} & \textbf{Element Ratio} & \textbf{Label Count Ratio} \\
        \midrule
        Count & 277.00 & 277.00 & 277.00 \\
        Mean & 8.87 & 6.04 & 5.81 \\
        Std & 0.18 & 0.12 & 0.31 \\
        Min & 8.24 & 5.62 & 3.42 \\
        25\% & 8.80 & 5.98 & 5.72 \\
        50\% & 8.88 & 6.03 & 5.82 \\
        75\% & 8.96 & 6.09 & 5.91 \\
        Max & 9.55 & 6.77 & 6.64 \\
        \bottomrule
    \end{tabular}
\end{table}

The C-Bit files generated through Btor2C translation are \textbf{8.87× larger} on average compared to direct BTOR2 representations. This substantial size difference has direct implications for storage requirements and I/O operations during verification.

\subsection{Label Complexity Analysis}
\label{subsec:label-complexity}

\begin{table}[htbp]
    \centering
    \caption{Label Complexity Comparison}
    \label{tab:label-complexity}
    \begin{tabular}{lrrrrr}
        \toprule
        \textbf{Format} & \textbf{Total Labels} & \textbf{Unique Labels} & \textbf{Duplication Ratio} & \textbf{Avg Length} & \textbf{Max Length} \\
        \midrule
        BTOR2 & 897,894 & 102,538 & 0.886 & 41.52 & 81 \\
        C-Bit & 3,688,148 & 302,613 & 0.918 & 46.88 & 520 \\
        \bottomrule
    \end{tabular}
\end{table}

The C-Bit format exhibits significantly higher label complexity, with \textbf{5.81× more labels} and longer average label lengths. This increased complexity may impact parsing performance and memory usage during model checking operations.

\section{Control Flow Analysis}
\label{sec:control-flow}

\subsection{Main Procedure Characteristics}
\label{subsec:main-procedure}

The analysis of main procedures reveals substantial differences in control flow complexity:

\begin{table}[htbp]
    \centering
    \caption{Main Procedure Statistics}
    \label{tab:main-procedure}
    \begin{tabular}{lrrrrrr}
        \toprule
        \textbf{Format} & \textbf{Locations} & \textbf{Edges} & \textbf{Variables} & \textbf{Complexity Score} \\
        & Mean ± Std & Mean ± Std & Mean ± Std & Mean ± Std \\
        \midrule
        BTOR2 & 2702 ± 946 & 1200 ± 416 & 1439 ± 500 & 1698 ± 591 \\
        C-Bit & 9593 ± 3358 & 4465 ± 1552 & 3856 ± 1363 & 5882 ± 2056 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Complexity Ratios and Performance Implications}
\label{subsec:complexity-ratios}

The C-Bit representation demonstrates significantly higher complexity across all measured dimensions:

\begin{itemize}
    \item \textbf{Locations:} 3.55× more in C-Bit (9593 vs 2702)
    \item \textbf{Edges:} 3.72× more in C-Bit (4465 vs 1200) 
    \item \textbf{Variables:} 2.68× more in C-Bit (3856 vs 1439)
    \item \textbf{Overall Complexity:} 3.46× higher in C-Bit
\end{itemize}

These differences have direct implications for model checking performance:

\begin{itemize}
    \item \textbf{State Space Exploration:} The higher number of edges may exponentially increase the state space exploration complexity
    \item \textbf{Memory Usage:} Increased locations and variables directly impact memory requirements during analysis
    \item \textbf{Analysis Time:} More complex control flow structures may lead to longer verification times
\end{itemize}

\section{Performance Impact Analysis}
\label{sec:performance-impact}

\subsection{Resource Requirements}
\label{subsec:resource-requirements}

Based on the structural analysis, the translation-based approach through Btor2C introduces significant overhead:

\paragraph{Memory and Storage Impact}
\begin{itemize}
    \item C-Bit files require \textbf{8.87× more storage} than direct BTOR2 representations
    \item The increased file sizes may impact I/O performance and memory mapping efficiency
    \item Larger working sets could lead to more cache misses and higher memory bandwidth requirements
\end{itemize}

\paragraph{Processing Overhead}
\begin{itemize}
    \item \textbf{5.81× more labels} require additional parsing and processing time
    \item \textbf{6.03× more structural elements} increase graph processing complexity
    \item Higher label duplication ratio (0.918 vs 0.886) indicates less efficient representation
\end{itemize}

\subsection{Control Flow Complexity Impact}
\label{subsec:control-flow-impact}

The analysis of main procedures reveals several performance concerns for the translation-based approach:

\paragraph{State Space Exploration}
\begin{itemize}
    \item \textbf{3.72× more edges} significantly increase branching complexity
    \item Larger state transition systems may lead to exponential growth in state space
    \item Increased path complexity may challenge abstraction refinement algorithms
\end{itemize}

\paragraph{Data Flow Analysis}
\begin{itemize}
    \item \textbf{2.68× more variables} increase the dimensionality of data flow analysis
    \item Larger variable sets require more complex abstract domains and larger SMT queries
    \item Increased memory requirements for storing variable states and relationships
\end{itemize}

\section{Threats to Validity}
\label{sec:threats-validity}

\subsection{Internal Validity}
\label{subsec:internal-validity}

\begin{itemize}
    \item \textbf{Benchmark Selection:} The 277 circuits from HWMCC represent a comprehensive set, but may not cover all hardware verification scenarios
    \item \textbf{Metric Selection:} The chosen metrics focus on structural complexity; runtime performance may show different patterns
    \item \textbf{Implementation Maturity:} The BTOR2XCFA implementation may have optimization opportunities not yet explored
\end{itemize}

\subsection{External Validity}
\label{subsec:external-validity}

\begin{itemize}
    \item \textbf{Generalizability:} Results are specific to hardware verification; software verification may show different characteristics
    \item \textbf{Toolchain Dependencies:} Findings may be influenced by specific versions of Theta, Btor2C, and associated libraries
    \item \textbf{Scale Considerations:} The analysis focuses on medium to large circuits; very small or extremely large circuits may behave differently
\end{itemize}

\section{Summary of Findings}
\label{sec:findings-summary}

The evaluation demonstrates clear advantages for the direct BTOR2-to-CFA transformation approach:

\begin{itemize}
    \item \textbf{Structural Efficiency:} BTOR2XCFA produces significantly more compact representations (8.87× smaller files)
    \item \textbf{Reduced Complexity:} Direct transformation maintains simpler control flow structures (3.46× lower complexity score)
    \item \textbf{Better Scalability:} Lower resource requirements suggest better scalability for large verification tasks
    \item \textbf{Semantic Preservation:} Direct mapping to CFA avoids potential semantic gaps introduced by C translation
\end{itemize}

These findings strongly support the hypothesis that direct transformation approaches can provide significant efficiency advantages over translation-based workflows for hardware model checking.

\endinput