%----------------------------------------------------------------------------
\chapter{\bevezetes}
%----------------------------------------------------------------------------

In recent years, the \textit{verification and validation of safety-critical and reliable systems} have gained increasing importance. Ensuring the correctness of both software and hardware components has become a central challenge in modern system development. At the foundation of these efforts lies \textbf{formal verification}, a field that provides mathematically rigorous methods for proving system correctness. Among its various techniques, \textbf{model checking}~\cite{modelChecking}\cite{systemEngineering} has emerged as one of the most prominent and widely used approaches.

There exists a wide range of \textbf{software and hardware verification tools}, many of which rely on transforming source languages into \textit{intermediate representations (IRs)} to enable analysis by different model checkers. This approach enhances interoperability and allows existing verification tools to be applied across multiple domains.

In the context of \textbf{hardware verification}, a well-known benchmark and competition is the \textit{Hardware Model Checking Competition (HWMCC)}~\cite{hwmcc}. Within this community, the \textbf{AIGER}~\cite{AIGER} format was introduced as a bit-level representation for hardware circuits. Although AIGER remains widely used, it has been largely superseded by \textbf{BTOR2}, a \textit{word-level model checking format} that describes circuits in a bit-precise yet higher-level manner. BTOR2 has gained popularity due to its \textbf{fixed and unambiguous semantics}, which allow tool developers to concentrate more on analysis techniques rather than dealing with ambiguous interpretations of the input format.

While several \textbf{hardware model checkers} natively support BTOR2, research has shown that \textit{translating BTOR2 models into software-oriented languages}, such as C, can sometimes reveal additional errors. One such tool, \textbf{Btor2C}~\cite{btor2c}, enables this cross-domain analysis by bridging hardware and software verification, allowing hardware circuits to be analyzed by \textbf{software model checkers}. Further translation pipelines also exist, for example converting \textit{Verilog~$\rightarrow$~BTOR2~$\rightarrow$~C}, making it possible to verify hardware descriptions using software analysis tools.

However, introducing Btor2C into the verification workflow adds \textbf{an additional translation step}, which may impact both performance and correctness. Each transformation introduces the possibility of semantic mismatches or implementation errors, and excessive conversion may reduce efficiency due to format-specific optimizations. Moreover, \textit{fundamental differences between hardware and software representations} -- such as arbitrary-width bit-vector types in BTOR2 -- make these translations nontrivial. Although Btor2C has been empirically validated, the transformation process remains prone to subtle semantic discrepancies.

\paragraph{Motivation} Currently, \textbf{no unified tool} exists that can directly perform model checking on both C programs and BTOR2 circuits. As mentioned above, repeated translations can introduce inefficiencies and semantic inconsistencies. To better understand the impact of such transformations, I conducted a \textbf{comparative analysis} focusing on the \textbf{Btor2C translation} and my own \textbf{direct transformation} from BTOR2 to a widely used formalism in software model checking -- \textbf{Control Flow Automata (CFA)}~\cite{cfa}. 

The goal of this analysis is to evaluate whether verifying hardware descriptions through software-oriented analyzers provides practical benefits, and to what extent the additional translation steps affect verification performance and accuracy.

\paragraph{Contribution} As part of this work, I \textbf{implemented a BTOR2 frontend} for the \textbf{abstraction-based model checking framework Theta}. My contribution includes a \textbf{BTOR2-to-XCFA parser pipeline} fully integrated into Theta. This parser reads BTOR2 files and constructs an \textbf{Extended Control Flow Automaton (XCFA)}, enabling Theta's reachability analysis to verify \textbf{hardware-like systems} expressed in BTOR2.

The implementation focuses on supporting \textbf{bit-vector operations} and modeling \textbf{simple sequential systems}, such as counters and state machines. With this integration, the Theta framework can now verify BTOR2 models using the same \textbf{formal reasoning techniques} that were previously applicable only to software systems.