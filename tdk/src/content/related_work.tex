\chapter{Related work}

% Btor2C
% Btor2Cert
% State Space-Based Methods for Validating Model Transformations in Model Checkers
\section{Related work}

\subsection{The Theta Framework and C Verification} 
The Theta framework [22] serves as the foundation for this work, providing a modular, extensible platform for model checking developed at the Budapest University of Technology and Economics. Theta employs abstraction-refinement-based reachability analysis and supports multiple formalisms through its frontend architecture. The framework's existing C frontend (c2CFA) transforms C programs into Control-Flow Automata (CFA), enabling various verification algorithms to operate on a unified intermediate representation. Theta's support for CEGAR (Counterexample-Guided Abstraction Refinement) and configurable abstract domains makes it particularly suitable for adapting to different verification domains.

\subsection{Btor2C and Translation-Based Workflows}

Btor2C [5] represents the state-of-the-art in hardware-to-software translation for verification purposes. This tool systematically converts BTOR2 circuits into C programs, enabling software verification tools to analyze hardware designs indirectly. The translation workflow allows leverage of sophisticated software verification techniques—such as those in CPAChecker [3] and ESBMC [16]—on hardware circuits. Empirical results have demonstrated that this approach can uncover bugs that dedicated hardware verifiers like ABC [9] and AVR [17] miss under identical time constraints.

However, the Btor2C approach introduces a multi-step translation process: BTOR2 → C → CFA → verification. Each transformation step potentially introduces semantic discrepancies and optimization barriers. Furthermore, the translation must bridge fundamental differences between hardware and software paradigms, particularly regarding arbitrary-width bit-vector types and cyclic behavior representation.

\subsection{Comparative Analysis of Verification Workflows}

Existing verification workflows can be categorized into two main approaches:

\subsubsection{Direct Hardware Verification}
\begin{itemize}
    \item \textbf{Tools}: ABC, AVR
    \item \textbf{Path}: BTOR2 $\rightarrow$ direct verification
    \item \textbf{Advantages}: Native hardware semantics, optimized for circuit structures
    \item \textbf{Limitations}: May not benefit from software verification advances
\end{itemize}

\subsubsection{Translation-Based Verification}
\begin{itemize}
    \item \textbf{Tools}: Btor2C + software verifiers
    \item \textbf{Path}: BTOR2 $\rightarrow$ C $\rightarrow$ CFA $\rightarrow$ verification
    \item \textbf{Advantages}: Access to software verification techniques
    \item \textbf{Limitations}: Additional translation layer, potential semantic gaps
\end{itemize}
