%----------------------------------------------------------------------------
\chapter{\bevezetes}
%----------------------------------------------------------------------------
Over the past decade, our understanding of and techniques for hardware verification have evolved significantly. Traditionally, hardware verification relied on simulation, where system behavior is tested against expected outcomes.~\cite{hardware_MC} While effective for small designs, simulation cannot guarantee full coverage and often fails to expose corner cases in complex circuits.

To overcome these limitations, \emph{formal verification} uses mathematical and logical techniques to prove or disprove the correctness of hardware designs. 
The main approaches are \emph{theorem proving}~\cite{theorem_proving1,theorem_proving2}, \emph{equivalence checking}~\cite{equivalence}, and \emph{model checking}~\cite{modelChecking,modelChecking2}. I will focus on model checking, which is widely adopted for sequential hardware. Model checking automatically determines whether a design satisfies its formal specification or produces a counterexample. 
Typically, the design is represented by a formal model (e.g., a transition system), and invariant verification ensures that the given properties hold in all reachable states.

Recent research has shown that translating hardware models into software and verifying them with software model checkers can reveal bugs not found by even state-of-the-art hardware analyzers such as ABC or AVR~\cite{ABC-hardware, AVR, hw_verification_using_sw}. The creators of the original idea peformed a transformation from $Verilog$ to $C$.~\cite{hw_verification_using_sw} Their experimental results showed that by using software analyzers the model checking process could be more than an order of magnitude faster. 

Ever since then, several approaches have aimed to translate hardware description languages into higher-level software representations, allowing existing software verifiers, such as \textsc{CPAChecker}~\cite{cpachecker} and \textsc{ESBMC}~\cite{esbmc}, to perform model checking indirectly. One notable effort is \textsc{Btor2C}~\cite{btor2c}, which converts \textsc{Btor2} circuits into C programs, enabling a wide range of software verification tools to analyze them.
\textsc{Btor2} has become the de facto standard intermediate representation for hardware model checking, officially adopted as the input format of the Hardware Model Checking Competition (HWMCC)~\cite{hwmcc}. It provides fixed, unambiguous semantics and aligns closely with SMT-LIB~\cite{SMT-LIB}, also making it a robust intermediate format for bit-level languages such as AIGER and Verilog.

\paragraph{Motivation} While \textsc{Btor2C} enables indirect verification, it introduces an additional translation step into C, which can reduce efficiency and increase the risk of transformation errors. Each intermediate step adds complexity and may hinder analysis performance due to redundant optimizations or semantic mismatches.
Moreover, hardware and software differ fundamentally. For instance, \textsc{Btor2} supports arbitrary-width bit-vector types that have no direct C equivalent. Although empirically validated, \textsc{Btor2C}â€™s translation remains nontrivial and potentially error-prone.

To address these issues, this work implements a direct transformation from \textsc{Btor2} to control-flow automata (CFA) \cite{cfa} within the \textsc{Theta}~\cite{theta} model checking framework. This approach preserves the exact semantics of bit-vectors through the SMT solver, naturally represents cyclic hardware behavior as graph loops, and enables \textsc{Btor2}-specific optimizations directly on the CFA, thus eliminating the need for intermediate C code and improving overall analysis efficiency.

The objective of this thesis is to conduct a comparative analysis and assess whether a dedicated \textsc{Btor2} frontend offers superior efficiency compared to translation-based verification workflows.

\paragraph{Contributions}
The outline of this work is as follows:
\begin{itemize}
    \item In~\autoref{chapter:bg}, I provide an overview of the necessary background concepts, including formal verification techniques, the \textsc{Btor2} format, control-flow automata, and the \textsc{Theta} framework.
    \item In~\autoref{chapter:btor2cfa}, I present the implementation of the \textsc{Btor2}-to-CFA transformation within the \textsc{Theta} framework, providing a unified verification environment capable of analyzing both hardware and software systems.
    \item \autoref{chapter:evaluation} presents a comprehensive evaluation of the direct \textsc{Btor2} frontend, empirically validating its efficiency advantages. This chapter provides a detailed comparative analysis of the formal representations generated by direct versus indirect transformations, alongside a performance benchmark of the various verification algorithms supported by \textsc{Theta}~\cite{theta}. Furthermore, it examines the specific impact of \textsc{Btor2}-oriented optimizations on overall verification efficiency.
\end{itemize}
