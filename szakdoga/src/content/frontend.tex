\chapter{BTOR2CFA: Implementation of a Direct BTOR2-to-CFA Translation for Verification}\label{chapter:btor2cfa}

In~\autoref{sec:motivation}, I discuss the motivation behind this work. Next, ~\autoref{sec:implementation} describes in detail the transformation implemented within Theta and presents illustrative examples. Finally, ~\autoref{sec:comparison_direct_indirect} explains the approach used to compare the direct and indirect transformations.

\section{Motivation}\label{sec:motivation}

\paragraph{Btor2C.} As discussed in previous chapters, numerous approaches have been proposed to verify hardware circuits using software analyzers. One notable example is \textit{Btor2C}~\cite{btor2c}, a tool originally conceived as a universal translator to convert hardware descriptions into C programs compatible with any standard software verifier. To achieve this universality while preserving precise hardware semantics, the generated C code often relies on abstract representations and indirections, particularly when modeling bitvector operations. This translation bridges the gap between hardware and software verification by enabling the use of existing C verification tools. In contrast, my work focuses on implementing a dedicated hardware frontend directly within an existing software model checker, eliminating the need for translation into C and its associated overhead.

\paragraph{Problem Statement.} Using C as an intermediate representation between \textsc{Btor2} and a formal model (in this case, a Control Flow Automaton, CFA) can introduce semantic discrepancies and reduce verification efficiency. This additional transformation layer may obscure the original hardware semantics and complicate the verification process. So far there was no unified tool in which both the direct and indirect transformation approaches can be compared fairly.

\autoref{fig:indirect} illustrates the difference between the two workflows. The indirect approach involves first translating the \textsc{Btor2} circuit into C code using \textsc{Btor2C}, followed by converting the C code into a CFA representation for verification. In contrast, the direct approach implemented in this work transforms the \textsc{Btor2} circuit directly into a CFA, bypassing the intermediate C representation entirely.

\begin{figure}
  \centering
  \includegraphics[width=1\textwidth]{figures/my_contribution.drawio.png}
  \caption{Workflow of direct and indirect transformation in software verification.}
  \label{fig:indirect}
\end{figure}

\paragraph{Proposed solution.} By implementing a \textsc{Btor2} frontend in \textsc{Theta}, a modular and extensible model checking framework, I aim to:
\begin{enumerate}
    \item Eliminate the intermediate C translation step,
    \item preserve native \textsc{Btor2} semantics through direct mapping to SMT solver types,
    \item enable \textsc{Btor2}-specific optimizations directly on the CFA representation,
    \item provide a unified framework for both hardware and software verification
\end{enumerate}

\section{Design and Implementation of the BTOR2 Frontend in Theta}\label{sec:implementation}

The implementation began with defining an unofficial \textsc{Btor2} grammar using ANTLR4~\cite{antlr}, a widely-adopted parser generator for constructing domain-specific languages. This grammar enables systematic parsing of BTOR2 circuits and extraction of circuit elements for transformation.

Control-Flow Automata (CFA) naturally represent sequential circuits through their directed graph structure. In~\autoref{fig:basicCFA}, I present a schematic overview of this representation and explain how each step corresponds to a specific node. The transformation from \textsc{BTOR2} to CFA follows a systematic mapping, where:

\begin{description}
  \item[Constants.] The transformation begins by adding all constant nodes defined in the \textsc{BTOR2} model (e.g., \verb|const|, \verb|zero|, \verb|one|, \verb|ones| etc.) to the initial CFA edge. These constants serve as fixed symbolic values throughout the verification process.
  \item[Initial states.] The \verb|init| keyword in \textsc{BTOR2} specifies initialization functions for state variables. In the CFA representation, these are defined on the subsequent edge, establishing the initial state configuration of the system.
  \item[Havoc assignments.] Nodes declared with the \verb|input| keyword, or state variables without an associated \verb|next| definition, are introduced after the initial state. These represent unconstrained inputs whose values may vary across different execution iterations.
  \item[Operations.] Next, the transformation processes all operation nodes (\verb|add|, \verb|and|, \verb|eq|, etc.) in topological order, sequentially creating corresponding CFA edges and locations for each operation to preserve the computational dependencies of the circuit.
  \item[Safety Properties.]  The \verb|bad| keyword defines the reachability property for verification. The transformation models this as a conditional transition originating from the referenced operation node. If the \verb|bad| condition is satisfied, the CFA branches to an error location; otherwise, the control flow proceeds to the next state update.
  \item[Next states.] Finally, if the safety property is not violated, all state variables defined with the \verb|next| keyword are updated accordingly, completing one iteration of the transition system.
\end{description}

\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{figures/sematikus_cfa.drawio.pdf}
  \caption{Schematic overview of the BTOR2CFA transformation process.}
  \label{fig:basicCFA}
\end{figure}

This mapping enables Theta to perform exhaustive reachability analysis, exploring all possible execution paths to determine whether error states are reachable from initial configurations.

\subsection{Example BTOR2 to CFA Transformation}

Figure~\ref{fig:btor2xcfa} illustrates the direct transformation from the count2.btor2 example to a simplified CFA. The \textsc{Btor2} circuit implements a 3-bit counter that increments each cycle and triggers a bad state when reaching the value 111.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figures/btor2xcfa.drawio.pdf}
    \caption{Simplified CFA from the count2.btor2 example}
    \label{fig:btor2xcfa}
\end{figure}

The transformation process maps:
\begin{itemize}
    \item The initial state assignment ($s_3 := 000$) from the \texttt{init} operation
    \item The increment operation ($n_6 := s_3 + 001$) as a computation edge
    \item The state update ($s_3 := n_6$) from the \texttt{next} operation
    \item The safety condition ($[s_3 == 111]$) from the \texttt{bad} property
\end{itemize}

The resulting CFA naturally captures the cyclic behavior of the hardware circuit as a graph loop, enabling efficient reachability analysis using Theta's verification algorithms.

\section{Comparison between Direct and Indirect Transformations}\label{sec:comparison_direct_indirect}

This section contrasts the direct \textsc{Btor2}-to-CFA transformation developed in this thesis against the traditional indirect workflow (via C). Implementing both approaches within the same verification framework (\textsc{Theta}) provides a solid foundation for a fair and consistent evaluation. By integrating both workflows into a single tool, differences in performance or accuracy can be attributed primarily to the transformation methodology itself, rather than to unrelated factors such as solver configurations or tool-specific heuristics.

\subsection{Conceptual Differences}

The fundamental distinction between the two approaches lies in their semantic fidelity to the original hardware description.

\paragraph{Direct Transformation (BTOR2CFA)}
The direct transformation approach establishes a one-to-one mapping from hardware circuits to formal verification models. Its primary goal is to preserve the native semantics of the hardware description without introducing unnecessary abstractions. By eliminating intermediate translation steps, this method maintains the structural integrity of the original circuit design and enables the exploitation of hardware-specific patterns -- such as bit-level logic and synchronous state updates -- that might otherwise be obscured.

\paragraph{Indirect Transformation (C2CFA)}
In contrast, indirect transformation approaches introduce additional abstraction layers. Translating hardware into software-oriented representations (like C) often results in conceptual mismatches, such as the disparity between hardware cycles and software loops. These discrepancies accumulate through successive translation steps, introducing artifacts that complicate the verification process.

To concretely illustrate these artifacts, \autoref{fig:btor2c_code} presents a snippet of C code generated by \textsc{Btor2C} for a simple counter circuit. Even for this trivial example, the translation introduces explicit type definitions, bit-masks (e.g., \texttt{mask\_SORT\_1}), and numerous auxiliary variables (e.g., \texttt{var\_10\_arg\_0}) to emulate bit-vector semantics. This visually demonstrates how the indirect approach inflates structural complexity compared to the concise original hardware description.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{figures/btor2c_prog.png}
    \caption{\texttt{count2.btor2} example translated to C by \textsc{Btor2C} (simplified version), illustrating the introduction of auxiliary masks and variables.}
    \label{fig:btor2c_code}
\end{figure}

\autoref{tab:btor2_vs_c_conceptual} summarizes these structural and semantic differences.

\begin{table}[h!]
\centering
\caption{Conceptual comparison of BTOR2 (Simple) and C (Complex) frontends}
\label{tab:btor2_vs_c_conceptual}
\renewcommand{\arraystretch}{1.3}
\small
\begin{tabular}{@{}p{3.5cm}p{5.5cm}p{5.5cm}@{}}
\toprule
\textbf{Category} & \textbf{BTOR2CFA (Direct)} & \textbf{C2CFA (Indirect)} \\
\midrule
\textbf{Variable dependencies} & 
Straightforward variable relations mirroring the netlist. & 
Introduction of numerous auxiliary variables for function calls and scope management. \\ \addlinespace

\textbf{Temporary variables} & 
Minimal use of temporary variables. & 
Extensive use of temporary variables for parameter passing and value copying. \\ \addlinespace

\textbf{State handling} & 
State is updated directly via next-state logic. & 
State is modified indirectly through function calls, pointers, and parameters. \\ \addlinespace

\textbf{Bit-level operations} & 
Bit-widths are handled natively and automatically. & 
Bit-widths must be enforced manually using explicit masking operations. \\ \addlinespace

\textbf{Control Structure} & 
Encapsulated in a single, simple procedure. & 
Fragmented across several procedures, incurring call overhead. \\ \addlinespace

\textbf{Instrumentation} & 
Minimal additional logic required. & 
Complex logic introduced to enforce C semantics and assertion checks. \\
\bottomrule
\end{tabular}
\end{table}

\section{Implementation Considerations and Optimization Trade-offs}

The choice of transformation pathway significantly influences the resulting model's complexity and the subsequent performance of the model checker.

\subsection{Theta's C Frontend: A Mature but Complex Infrastructure}

\textsc{Theta}'s existing C frontend is a highly optimized and robust component, refined over years to handle the complexities of software verification with high efficiency. It excels at processing standard C programs, accurately modeling memory safety, pointer arithmetic, and control flow.

However, when applied to hardware verification via the Btor2C workflow, its performance is impacted not by its own design, but by the nature of the input it receives:
\begin{itemize}
    \item \textbf{Inherited Structural Complexity:} The structural overhead observed in the C workflow is primarily an artifact of the \textsc{Btor2C} translation tool, not the frontend itself. To simulate hardware parallelism and bit-vector semantics within the sequential C language, \textsc{Btor2C} must generate explicit bit-masks, temporary variables, and auxiliary assignments. The C frontend faithfully models this verbose input, resulting in a bloated CFA that accurately reflects the C code but obscures the original, concise hardware logic.
    \item \textbf{Semantic Mismatch:} The C frontend is designed to analyze software idioms. When hardware logic is emulated using C constructs (e.g., modeling cyclic state updates via function calls or loops), the frontend processes them as standard software control flow. This emulation acts as an optimization barrier, as the underlying solver must reason about the complex emulation logic rather than the simple bit-vector transitions of the original circuit.
\end{itemize}

\subsection{BTOR2 Frontend: Minimalist and Domain-Specific}

In contrast, the \textsc{Btor2} frontend was implemented to leverage the foundational concepts of the \textsc{Theta} framework while adhering strictly to standard SMT-LIB semantics. By utilizing \textsc{Theta}'s existing type system and expression hierarchy, the direct transformation ensures rigorous formal verification standards and compatibility with downstream SMT solvers.

Key design advantages include:
\begin{itemize}
    \item \textbf{Direct Mapping:} Bit-vector types map directly to SMT solver types, preserving precise semantics without intermediate representation.
    \item \textbf{Graph-Based Loops:} Cyclic behavior is naturally expressed as CFA loops, avoiding the need for the explicit unrolling or simulation constructs often found in C translations.
    \item \textbf{Targeted Optimizations:} Domain-specific optimizations, such as Large-Block Encoding and variable elimination, can be applied directly to the CFA. This reduces redundancy and improves solver performance by presenting a cleaner state space.
\end{itemize}

\section{Limitations of the Current Implementation}

While the direct transformation offers significant advantages, the current implementation has specific limitations regarding applicability and feature support:

\begin{itemize}
    \item \textbf{Incomplete Language Support:} The frontend currently limits the scope of verifiable circuits due to two primary gaps in the \textsc{Btor2} specification coverage:
    \begin{itemize}
        \item \textit{Missing Operators:} Specific arithmetic and bit-manipulation operators, such as overflow predicates (e.g., \texttt{saddo}, \texttt{uaddo}) and reduction operations (e.g., \texttt{redand}, \texttt{redor}), are not yet implemented.
        \item \textit{Lack of Array Support:} The tool currently provides no support for the \textsc{Btor2} array sort or associated array operations (e.g., \texttt{read}, \texttt{write}), preventing the verification of designs that rely on memory modeling.
    \end{itemize}
    \item \textbf{No Witness Generation:} The tool does not yet generate counterexamples or witness files. This hinders integration into formal verification competitions (like SV-COMP) and industrial workflows that require actionable feedback for debugging.
    \item \textbf{Limited Property Scope:} Verification is currently restricted to safety properties (\texttt{bad} states). Liveness properties (e.g., \texttt{justice}, \texttt{fairness}) and other temporal specifications remain unsupported.
\end{itemize}