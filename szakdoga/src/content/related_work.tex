\chapter{Related work}

% Btor2C
% Btor2Cert
% State Space-Based Methods for Validating Model Transformations in Model Checkers
\section{Related work}

\subsection{Btor2C and Translation-Based Workflows}

As discussed in this work, numerous translation-based workflows exist, with Btor2C~\cite{btor2c} being the most notable example. The authors of Btor2C investigated a fundamental architectural question: is it more effective to employ a universal translation tool to bridge hardware and software model checking, or is it more advantageous to extend individual software analyzers with dedicated hardware-specific frontends? This critical inquiry served as a primary inspiration for the research presented in this thesis.

Btor2C represents the state-of-the-art in hardware-to-software translation for verification purposes. The tool systematically converts \textsc{Btor2} circuits into C programs, enabling software verification tools to analyze hardware designs indirectly. This workflow facilitates the application of sophisticated software verification techniques -- such as those found in \textsc{CPAchecker}~\cite{cpachecker} and \textsc{ESBMC}~\cite{esbmc} -- to hardware circuits. Empirical results have demonstrated that this approach can uncover bugs that dedicated hardware verifiers like ABC~\cite{ABC-hardware} and AVR~\cite{AVR} miss under identical time constraints.

However, the Btor2C approach introduces a multi-step translation process: \textsc{Btor2} $\rightarrow$ C $\rightarrow$ CFA $\rightarrow$ verification. Each transformation step potentially introduces semantic discrepancies and creates barriers to optimization. Furthermore, the translation must bridge fundamental differences between hardware and software paradigms, particularly regarding arbitrary-width bit-vector types and the representation of cyclic behavior.

\subsection{Comparative Analysis of Verification Workflows}

Verification workflows for hardware systems fall into two principal approaches with distinct trade-offs. Despite the advantages of each, detailed comparative analyses are scarce. The following discussion outlines the specific benefits and drawbacks associated with these workflows.

\subsubsection{Direct Hardware Verification}

The direct hardware verification paradigm utilizes specialized engines, such as \textbf{ABC} and \textbf{AVR}, which ingest and process hardware description formats natively. This methodology adheres to a streamlined verification trajectory: \(\text{BTOR2} \rightarrow \text{direct verification}\). The distinct advantage of this approach is its preservation of native hardware semantics and bit-level abstractions, allowing for optimizations specifically tailored to circuit logic and state-space traversal. However, this specialization can also be a limitation; by operating in isolation, direct hardware verifiers may fail to capitalize on the rapid algorithmic advancements and heuristic innovations emerging from the broader software verification community.

\subsubsection{Translation-Based Verification}

Translation-based verification constitutes a hybrid paradigm designed to bridge the gap between hardware models and software analysis techniques. This workflow employs tools such as \textbf{Btor2C} in conjunction with software verifiers, executing a multi-stage transformation process: \(\text{BTOR2} \rightarrow \text{C} \rightarrow \text{CFA} \rightarrow \text{verification}\). The primary strength of this approach lies in its capacity to harness the mature ecosystem of software verification, granting access to sophisticated techniques -- including advanced abstract interpretation, lazy abstraction, and diverse model checking algorithms -- that are often absent in dedicated hardware tools. Conversely, the requisite translation introduces a semantic impedance mismatch. The conversion from hardware concurrency to software sequentiality can create optimization barriers and semantic gaps, potentially degrading verification efficiency and accuracy.