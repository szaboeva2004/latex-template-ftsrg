\pagenumbering{roman}
\setcounter{page}{1}

\selecthungarian

%----------------------------------------------------------------------------
% Abstract in Hungarian
%----------------------------------------------------------------------------
\chapter*{Kivonat}\addcontentsline{toc}{chapter}{Kivonat}

Az elmúlt években a formális verifikáció területe mind az akadémiai kutatásban, mind az ipari gyakorlatban egyre nagyobb jelentőségre tett szert, mivel a szoftver- és hardverrendszerek helyessége és megbízhatósága kritikus fontosságú kérdéssé vált. A modellellenőrzés, amely e terület egyik központi technikája, automatizált módszert kínál a rendszer tulajdonságainak szigorú ellenőrzésére. Ennek elérése érdekében a modellellenőrzők a bemeneti modellt formális ábrázolásba (pl. Control Flow Automata, avagy CFA) alakítják át, majd kimerítően felfedezik az összes lehetséges viselkedést egy adott tulajdonság ellenőrzése érdekében.  

A \btorFormat a legkorszerűbb, szószintű modellellenőrzési formátum, amely bitpontosan írja le a hardver áramköröket. Ahelyett, hogy a hardverdizájnokat közvetlenül komplex hardverleíró nyelveken, például Verilogban kellene ellenőrizni, a \btorFormat rögzített és egyértelmű szemantikát biztosít. Ez megkönnyíti a modellellenőrzők fejlesztőinek a munkáját, akik így magára a modellellenőrzésre koncentrálhatnak.  

Számos hardveres modellellenőrző áll rendelkezésre, amelyek közvetlenül ellenőrzik a \btorFormat áramköröket (pl. ABC, AVR). Más alkalmazási területeken, például a szoftvereknél, azonban olyan új technikákat fejlesztettek ki, amelyek nem feltétlenül állnak rendelkezésre ezekben a hardveres ellenőrzőkben. Ezen hiány pótlásában segít a Btor2C eszköz, amely a \btorFormat áramköröket C programokká alakítja át, így lehetővé téve, hogy számos szoftveres ellenőrző is képes legyen a \btorFormat ellenőrzésére. E munka eredményei azt mutatták, hogy a szoftverellenőrzők ugyanazon időkorlát mellett olyan hibákat tudtak megtalálni, amelyeket a hardverellenőrzők nem. 

A Btor2C használata azonban egy további átalakítási lépést jelent a C kódban, ami hatással lehet a hatékonyságra, miközben növeli az egyes lépésekkel kapcsolatos implementációs problémák esélyét. Az ismétlődő átalakítások és a végeredményre szabott optimalizálások hátráltathatják a modellellenőrzési elemzés teljesítményét. Ezenkívül a forráskód és a hardver áramkörök között alapvető különbségek vannak - például a \btorFormat tetszőleges szélességű bitvektorokkal dolgozik. Bár a Btor2C empirikusan validálásra került, a fent említett különbségek miatt az átalakítás nem triviális, ami implementációs problémákra hajlamossá teszi.  

Jelenleg nincs olyan eszköz, amely képes lenne közvetlenül ellenőrizni mind a C programokat, mind a \btorFormat áramköröket, ami megakadályozza a hatékonyság megbízható összehasonlítását. Ezért ebben a dolgozatban a Theta modellellenőrzési keretrendszerben megvalósítom a \btorFormat-ről CFA-ra történő közvetlen átalakítást. Így a bitvektor típusok közvetlenül használhatják a megoldás alapjául szolgáló SMT megoldók azonos szemantikájú típusait, valamint a ciklusok is természetesen kifejezhetőek gráfhurokként. Továbbá a közvetlen transzformáció lehetővé tette számomra, hogy a CFA-n \btorFormat-specifikus optimalizálási lépéseket implementáljak.  

Arra alapozva, hogy a Theta már képes volt C programokat CFA-vá alakítani, megterveztem és megvalósítottam egy összehasonlító kiértékelést, amelyben ugyanazon algoritmusok teljesítményét elemeztem különböző transzformációs láncok használata esetén. A megbízható értékelés érdekében a Hardware Model Checking Competition legkorszerűbb benchmark gyűjteményében elérhető hardver áramköröket használtam, amelyek átfogó és széles körben elfogadott alapot nyújtanak a hardverellenőrző eszközök teljesítmények összehasonlításához.  

\vfill
\selectenglish


%----------------------------------------------------------------------------
% Abstract in English
%----------------------------------------------------------------------------
\chapter*{Abstract}\addcontentsline{toc}{chapter}{Abstract}

In recent years, formal verification has gained increasing importance in both academic research and industrial practice, as the correctness and reliability of software and hardware systems have become critical concerns. Model checking, one of the central techniques in this domain, provides an automated way to rigorously verify system properties. To achieve this, model checkers transform the input model into a formal representation (e.g., Control Flow Automata) and then exhaustively explore all possible behaviors to verify a given property.  

\btorFormat is the state-of-the-art, word-level model checking format, which describes hardware circuits in a bit-precise manner. Instead of verifying hardware designs directly on complex hardware description languages such as Verilog, \btorFormat provides fixed and unambiguous semantics, enabling tool developers to focus more on the model checking analysis.  

Several available hardware model checkers can directly verify \btorFormat circuits (e.g., ABC, AVR). However, researchers of other application domains, such as software, have been developing new techniques not necessarily available in hardware verifiers. To bridge this gap, the tool Btor2C has been developed to transform \btorFormat circuits to C programs, making a wide array of software verifiers capable of verifying \btorFormat. Results of that work have shown that software verifiers can find bugs that hardware verifiers were not able to find, given the same time limit.  

However, utilizing Btor2C introduces an extra transformation step to C code, which might affect effectiveness, while also increasing the chance of implementation issues with each step. The repeating transformations and end-result specific optimizations might hinder the performance of the model checking analysis. Furthermore, software code and hardware have fundamental differences (e.g., arbitrary-width bit-vector types in \btorFormat). Although Btor2C is empirically validated, the transformation is not trivial due to the above-mentioned differences, making it more prone to hidden issues.  

Currently, no single tool is capable of directly model checking both C programs and \btorFormat circuits, prohibiting a fair comparison of effectiveness. Thus, in this work, I implement the direct transformation from \btorFormat to CFAs in the Theta model checking framework. With this direct transformation, bit-vector types can directly use the underlying SMT solver types with the same semantics, and cyclic behavior can be expressed naturally as graph loops. Furthermore, the direct transformation allowed me to implement \btorFormat-specific optimization passes on the CFA.  

With Theta’s ability to transform C programs into CFAs, I designed and executed a comparative evaluation of algorithm performance under different transformation chains. For a reliable evaluation, I used the hardware circuits available in the state-of-the-art benchmark suite of the Hardware Model Checking Competition, which provides a comprehensive and widely accepted basis for comparing hardware verification tools. 

\vfill
\cleardoublepage

\selectthesislanguage

\newcounter{romanPage}
\setcounter{romanPage}{\value{page}}
\stepcounter{romanPage}